"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkgithub_io_demo"] = self["webpackChunkgithub_io_demo"] || []).push([["src_utils_providerVue_js"],{

/***/ "./src/static/guide-mini-vue-esm.js":
/*!******************************************!*\
  !*** ./src/static/guide-mini-vue-esm.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createApp: () => (/* binding */ createApp),\n/* harmony export */   createRender: () => (/* binding */ createRender),\n/* harmony export */   createTextVNode: () => (/* binding */ createTextVNode),\n/* harmony export */   getCurrentInstance: () => (/* binding */ getCurrentInstance),\n/* harmony export */   h: () => (/* binding */ h),\n/* harmony export */   inject: () => (/* binding */ inject),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   provider: () => (/* binding */ provider),\n/* harmony export */   proxyRef: () => (/* binding */ proxyRef),\n/* harmony export */   reactive: () => (/* binding */ reactive),\n/* harmony export */   ref: () => (/* binding */ ref),\n/* harmony export */   renderSlots: () => (/* binding */ renderSlots)\n/* harmony export */ });\nconst Fragment = Symbol('Fragment');\r\nconst Text = Symbol('Text');\r\nfunction createVNode(type, props, children) {\r\n    const vNode = {\r\n        type,\r\n        props,\r\n        children,\r\n        component: null,\r\n        key: props && props.key,\r\n        shapeFlag: getShapeFlag(type),\r\n        el: null\r\n    };\r\n    // 子节点是\r\n    if (typeof children === 'string') {\r\n        vNode.shapeFlag |= 4 /* ShapeFlags.TEXT_CHILDREN */;\r\n    }\r\n    else if (Array.isArray(children)) {\r\n        vNode.shapeFlag |= 8 /* ShapeFlags.ARRAY_CHILDREN */;\r\n    }\r\n    // slot - 组件&object\r\n    if (vNode.shapeFlag & 2 /* ShapeFlags.STATEFUL_COMPONENT */) {\r\n        if (typeof children === 'object') {\r\n            vNode.shapeFlag |= 16 /* ShapeFlags.SLOT_CHILDREN */;\r\n        }\r\n    }\r\n    return vNode;\r\n}\r\nfunction getShapeFlag(type) {\r\n    return typeof type === 'string'\r\n        ? 1 /* ShapeFlags.ELEMENT */\r\n        : 2 /* ShapeFlags.STATEFUL_COMPONENT */;\r\n}\r\nfunction createTextVNode(text) {\r\n    return createVNode(Text, {}, text);\r\n}\r\n\r\nfunction h(type, props, children) {\r\n    return createVNode(type, props, children);\r\n}\r\n\r\nfunction renderSlots(slots, name, props) {\r\n    // 根据插槽名从slots对象中取出对应插槽\r\n    const slot = slots[name];\r\n    if (slot) {\r\n        if (typeof slot === \"function\") {\r\n            // 这里的 slot 是在initSlots中初始化后的函数 slots[key] = props => normalizeSlotValue(value(props))\r\n            return createVNode(Fragment, {}, slot(props));\r\n        }\r\n    }\r\n}\r\n\r\nconst extend = Object.assign;\r\nconst EMPTY_OBJECT = {};\r\nfunction isObject(val) {\r\n    return val !== null && typeof val === 'object';\r\n}\r\nconst hasChange = (oldValue, newValue) => {\r\n    return !Object.is(oldValue, newValue);\r\n};\r\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\r\nconst camelize = (str) => {\r\n    return str.replace(/-(\\w)/g, (_, c) => {\r\n        return c ? c.toUpperCase() : '';\r\n    });\r\n};\r\nconst capitalize = (str) => {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n};\r\nconst toHandleKey = (str) => {\r\n    return str ? 'on' + capitalize(str) : '';\r\n};\r\n\r\nconst publicPropertiesMap = {\r\n    $el: i => i.vNode.el,\r\n    $slots: i => i.slots,\r\n    $props: i => i.props\r\n};\r\nconst PublicInstanceProxyHandlers = {\r\n    // 取出组件的实例对象 instance\r\n    get({ _: instance }, key) {\r\n        // 从组件实例中取出 setupState（setup返回的数据） / props（传入当前组件的数据）\r\n        const { setupState, props } = instance;\r\n        // 当通过代理对象访问某个属性时，会先从 setupState 中查找并返回\r\n        if (hasOwn(setupState, key)) {\r\n            return setupState[key];\r\n        }\r\n        else if (hasOwn(props, key)) { // 如果setupState中没有，则到props中查找并返回\r\n            return props[key];\r\n        }\r\n        // 访问 $el、$slots、$props时，返回实例上对应的属性\r\n        const publicGetter = publicPropertiesMap[key];\r\n        if (publicGetter) {\r\n            return publicGetter(instance);\r\n        }\r\n    }\r\n};\r\n\r\n// 将没有处理过的props给到instance\r\nfunction initProps(instance, rawProps) {\r\n    instance.props = rawProps || {};\r\n    // attrs\r\n}\r\n\r\nfunction initSlots(instance, children) {\r\n    const { vNode } = instance;\r\n    if (vNode.shapeFlag & 16 /* ShapeFlags.SLOT_CHILDREN */) {\r\n        normalizeObjectSlot(children, instance.slots);\r\n    }\r\n}\r\nfunction normalizeObjectSlot(children, slots) {\r\n    for (const key in children) {\r\n        const value = children[key];\r\n        // 将 slots 设置为对象，从里面根据插槽名取出对应插槽\r\n        // normalizeSlotValue 接受的是结果，但此时value是函数，且需要传入props\r\n        slots[key] = props => normalizeSlotValue(value(props));\r\n    }\r\n}\r\nfunction normalizeSlotValue(value) {\r\n    return Array.isArray(value) ? value : [value];\r\n}\r\n\r\nlet activeEffect; // 全局变量保存effect\r\nlet shouldTrack; // 是否应该收集依赖\r\nclass ReactiveEffect {\r\n    constructor(fn, scheduler) {\r\n        this.scheduler = scheduler;\r\n        this.active = true; // true的时候，说明依赖没有清除\r\n        this.deps = [];\r\n        this._fn = fn;\r\n    }\r\n    run() {\r\n        /*\r\n        * stop状态：不收集依赖\r\n        * */\r\n        // 是否收集依赖用shouldTrack做区分\r\n        if (!this.active) {\r\n            return this._fn(); // stop状态直接执行fn就可以了\r\n        }\r\n        /*\r\n        * !stop状态：需要收集依赖\r\n        * */\r\n        shouldTrack = true; // 不是stop状态应该将开关打开（不是stop状态，就让它可以收集依赖）\r\n        activeEffect = this; // 当前的effect实例\r\n        const result = this._fn(); // 执行fn，会触发响应式对象的get操作，在get操作中去收集依赖\r\n        // 需要reset的操作\r\n        shouldTrack = false; // 重置为false，默认是不能收集依赖的\r\n        return result;\r\n    }\r\n    stop() {\r\n        if (this.active) {\r\n            cleanUpEffect(this);\r\n            if (this.onStop) {\r\n                this.onStop();\r\n            }\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\n// 删除依赖\r\nfunction cleanUpEffect(effect) {\r\n    effect.deps.forEach((dep) => {\r\n        dep.delete(effect);\r\n    });\r\n    /*\r\n    * 一个effect关联的所有依赖都在它的deps属性中\r\n    * 所以清空一个effect的依赖就相当于让它的deps属性的长度为0\r\n    * */\r\n    effect.deps.length = 0;\r\n}\r\nconst targetMap = new Map(); // 一个对象的所有依赖保存在这里面\r\n/* 收集依赖 */\r\nfunction track(target, key) {\r\n    /*\r\n    * 优化点1：如果不需要收集依赖，下面的代码不需要执行了\r\n    * */\r\n    // if (!activeEffect) return\r\n    // if (!shouldTrack) return\r\n    if (!isTracking())\r\n        return;\r\n    // 收集依赖，这些依赖是唯一的（set数据结构）\r\n    // target ---对应---> key ---对应---> dep\r\n    let depsMap = targetMap.get(target); // 一个对象的key对应的所有依赖保存在这里面\r\n    // 初始化\r\n    if (!depsMap) {\r\n        depsMap = new Map();\r\n        targetMap.set(target, depsMap);\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        dep = new Set();\r\n        depsMap.set(key, dep);\r\n    }\r\n    trackEffects(dep);\r\n}\r\n/*\r\n* 抽离保存依赖的操作，方便ref复用\r\n* 因为ref只有一个value值，所以不需要通过Map来收集多个属性的依赖\r\n*   只需要一个set来保存value属性的依赖就行\r\n* */\r\nfunction trackEffects(dep) {\r\n    // 如果已经收集了，直接return掉\r\n    if (dep.has(activeEffect))\r\n        return;\r\n    dep.add(activeEffect);\r\n    activeEffect.deps.push(dep);\r\n}\r\nfunction isTracking() {\r\n    return shouldTrack && activeEffect !== undefined;\r\n}\r\nfunction effect(fn, options = {}) {\r\n    const _effect = new ReactiveEffect(fn, options.scheduler);\r\n    _effect.run();\r\n    // _effect.onStop = options.onStop\r\n    // Object.assign(_effect, options)\r\n    extend(_effect, options);\r\n    const runner = _effect.run.bind(_effect);\r\n    runner.effect = _effect;\r\n    return runner;\r\n}\r\n/* 触发依赖 */\r\nfunction trigger(target, key) {\r\n    let depsMap = targetMap.get(target);\r\n    let dep = depsMap.get(key);\r\n    triggerEffects(dep);\r\n}\r\nfunction triggerEffects(dep) {\r\n    for (const effect of dep) {\r\n        if (effect.scheduler) {\r\n            effect.scheduler();\r\n        }\r\n        else {\r\n            effect.run();\r\n        }\r\n    }\r\n}\r\n\r\n// 抽离get\r\nconst get = createGetter();\r\nconst set = createSetter();\r\nconst readonlyGet = createGetter(true);\r\nconst shallowReadonlyGet = createGetter(true, true);\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key) {\r\n        // 如果访问的key是 is_reactive，就说明调用了isReactive\r\n        if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\r\n            // 如果isReadonly是false，就说明它是一个reactive\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        const res = Reflect.get(target, key);\r\n        /*\r\n        * 检查是不是shallowReadonly，如果是（shallowReadonly包含两个条件：1.不需要嵌套 2.是readonly，不需要收集依赖），\r\n        *   则不需要进行包装，直接返回res就可以\r\n        * */\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        /*\r\n        * 检查res是不是 普通对象，如果是普通对象，使用reactive包装它并返回\r\n        * readonly的嵌套也也是在这里实现，根据 isReadonly判断\r\n        *   如果是 isReadonly === true 用readonly包装并返回，否则用reactive包装并返回\r\n        *\r\n        * 这块我自己有一个问题，就是在这里返回 res 下面收集依赖操作难道就不需要了吗？\r\n        * 思考了下，答案是需要的，不过收集依赖并不是在这一层做的，因为它 res 是一个普通对象，\r\n        *   所以在这里收集依赖是没有意义的，而且也收集不了，通过reactive包装之后，会在包装的这一层\r\n        *   去收集依赖。\r\n        * */\r\n        if (isObject(res)) {\r\n            // return reactive(res)\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        // 检查是否是reactive，如果是reactive，则需要收集依赖\r\n        if (!isReadonly) {\r\n            track(target, key);\r\n        }\r\n        return res;\r\n    };\r\n}\r\n// 抽离set\r\nfunction createSetter() {\r\n    return function set(target, key, value) {\r\n        const res = Reflect.set(target, key, value);\r\n        trigger(target, key);\r\n        return res;\r\n    };\r\n}\r\nconst mutableHandles = {\r\n    get,\r\n    set\r\n};\r\nconst readonlyHandles = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        console.warn(`key: ${key} set 失败，因为target是readonly`, target);\r\n        return true;\r\n    }\r\n};\r\nconst shallowReadonlyHandlers = extend({}, readonlyHandles, {\r\n    get: shallowReadonlyGet\r\n});\r\n\r\nfunction reactive(raw) {\r\n    return createReactiveObject(raw, mutableHandles);\r\n}\r\n// 只读，意味着不能set\r\nfunction readonly(raw) {\r\n    return createReactiveObject(raw, readonlyHandles);\r\n}\r\nfunction createReactiveObject(raw, baseHandlers) {\r\n    if (!isObject(raw)) {\r\n        console.warn(`raw ${raw}必须是一个对象`);\r\n        return raw;\r\n    }\r\n    return new Proxy(raw, baseHandlers);\r\n}\r\nfunction shallowReadonly(raw) {\r\n    return createReactiveObject(raw, shallowReadonlyHandlers);\r\n}\r\n\r\nfunction emit(instance, event, ...args) {\r\n    const { props } = instance;\r\n    // Tpp - 先写特定的行为 -> 重构成通用的行为\r\n    // add -> Add\r\n    // add-foo -> AddFoo\r\n    const handlerName = toHandleKey(camelize(event));\r\n    const handler = props[handlerName];\r\n    handler && handler(...args);\r\n}\r\n\r\n/*\r\n* 创建一个ref的类\r\n* */\r\nclass RefImpl {\r\n    constructor(value) {\r\n        this.__v_isRef = true;\r\n        // 如果这个value是一个对象，那么需要通过reactive给它进行包装\r\n        // 1.检查value是不是对象\r\n        this._value = convert(value);\r\n        this._rawValue = value;\r\n        // this._value = value\r\n        this.dep = new Set();\r\n    }\r\n    get value() {\r\n        trackRefValue(this);\r\n        return this._value;\r\n    }\r\n    set value(newValue) {\r\n        /*\r\n        * newValue -> this._value，如果相等不需要执行操作\r\n        * todo 抽离成hasChange\r\n        * */\r\n        // if (Object.is(newValue, this._value)) return\r\n        /*\r\n        * 对比的时候呢，是需要对两个原始值进行对比，而如果value是一个对象的话，this._value就成了reactive\r\n        *   所以传入的value如果是对象，在对比前需要将reactive转为原始对象\r\n        * 解决办法：初始化RefImpl的时候，声明一个值（_rawValue）保存传入的value，对比的时候就使用_rawValue对比\r\n        * */\r\n        if (hasChange(newValue, this._rawValue)) {\r\n            // 一定需要先去修改value，再去触发依赖\r\n            this._rawValue = newValue;\r\n            this._value = convert(newValue);\r\n            triggerEffects(this.dep);\r\n        }\r\n    }\r\n}\r\nfunction convert(value) {\r\n    return isObject(value) ? reactive(value) : value;\r\n}\r\nfunction trackRefValue(ref) {\r\n    if (isTracking()) {\r\n        trackEffects(ref.dep);\r\n    }\r\n}\r\nfunction ref(value) {\r\n    return new RefImpl(value);\r\n}\r\n// 判断传入的值是不是ref\r\nfunction isRef(ref) {\r\n    // 如果传入的是一个原始数据类型，那么将返回undefined，所以通过取反两次将其转为布尔值\r\n    return !!ref.__v_isRef;\r\n}\r\n// 传入一个ref数据，返回它的原始值\r\nfunction unRef(ref) {\r\n    // 如果是ref，返回它的value属性，否则直接返回就可以\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\n// 代理ref，比如在vue模板（template）中使用ref时，不需要.value\r\nfunction proxyRef(objectWithRefs) {\r\n    return new Proxy(objectWithRefs, {\r\n        get(target, key) {\r\n            return unRef(Reflect.get(target, key));\r\n        },\r\n        /*\r\n        * set的时候判断它是不是ref类型，如果是ref类型，那么需要修改它的value属性\r\n        * */\r\n        set(target, key, value) {\r\n            /*\r\n            * 当前的值是ref 且 将要更新的值不是ref的时候，需要给当前值（target[value]）的value属性赋值\r\n            * 否则直接给这个当前值取赋值就可以（这个重点在于当前值（target[key]）是不是ref，如果不是那么做简单的赋值操作就可以）\r\n            *   1.在当前值不是一个ref，将要更新的值是ref，也是直接赋值：target[key] = value\r\n            *   2.两个都不是ref的情况下，简单赋值就可以：target[key] = value\r\n            * 在当前值（target[key]）是一个ref，将要更新的值也是ref的情况下（两个值都是引用类型），\r\n            *     需要修改的就是target[key]的指针，要做的操作也是：target[key] = value\r\n            * */\r\n            if (isRef(target[key]) && !isRef(value)) {\r\n                return target[key].value = value;\r\n            }\r\n            else {\r\n                return Reflect.set(target, key, value);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction createComponentInstance(vNode, parent) {\r\n    const component = {\r\n        vNode,\r\n        type: vNode.type,\r\n        next: null,\r\n        setupState: {},\r\n        props: {},\r\n        slots: {},\r\n        parent,\r\n        providers: parent ? parent.providers : {},\r\n        isMounted: false,\r\n        subTree: {},\r\n        emit: () => { }\r\n    };\r\n    component.emit = emit.bind(null, component);\r\n    return component;\r\n}\r\nfunction setupComponent(instance) {\r\n    // TODO\r\n    initProps(instance, instance.vNode.props);\r\n    initSlots(instance, instance.vNode.children);\r\n    setupStatefulComponent(instance);\r\n}\r\nfunction setupStatefulComponent(instance) {\r\n    // 第一次patch的时候instance.type就是传入的App组件\r\n    const Component = instance.type;\r\n    // 创建一个代理对象用来拦截render函数中的this  目标对象有一个 _ 属性，它的值是当前组件的实例对象\r\n    instance.proxy = new Proxy({ _: instance }, PublicInstanceProxyHandlers);\r\n    const { setup } = Component;\r\n    if (setup) {\r\n        // currentInstance = instance\r\n        setCurrentInstance(instance);\r\n        // 因为传入的props是浅只读的，所以使用 shallowReadonly 包裹\r\n        const setupResult = setup(shallowReadonly(instance.props), {\r\n            emit: instance.emit,\r\n        });\r\n        // currentInstance = null\r\n        setCurrentInstance(null);\r\n        handleSetupResult(instance, setupResult);\r\n    }\r\n}\r\nfunction handleSetupResult(instance, setupResult) {\r\n    // TODO\r\n    if (typeof setupResult === 'object') {\r\n        // 为ref类型的数据做代理，可以直接访问，不需要.value\r\n        instance.setupState = proxyRef(setupResult);\r\n    }\r\n    finishComponentSetup(instance);\r\n}\r\nfunction finishComponentSetup(instance) {\r\n    const Component = instance.type;\r\n    if (Component.render) {\r\n        instance.render = Component.render;\r\n    }\r\n}\r\nlet currentInstance = null;\r\nfunction getCurrentInstance() {\r\n    return currentInstance;\r\n}\r\nfunction setCurrentInstance(instance) {\r\n    currentInstance = instance;\r\n}\r\n\r\n/*\r\n* 实际上是数据的存取\r\n* 存在当前的组件实例上\r\n*\r\n* provider/inject只能在setup下使用,因为只有才setup中才能获取到currentInstance\r\n* */\r\nfunction provider(key, value) {\r\n    // 存\r\n    const currentInstance = getCurrentInstance();\r\n    if (currentInstance) {\r\n        let { providers } = currentInstance;\r\n        const parentProviders = currentInstance.parent.providers;\r\n        // 初始化的时候才会执行\r\n        if (providers === parentProviders) {\r\n            providers = currentInstance.providers = Object.create(parentProviders);\r\n        }\r\n        providers[key] = value;\r\n    }\r\n}\r\nfunction inject(key, defaultValue) {\r\n    // 取\r\n    const currentInstance = getCurrentInstance();\r\n    if (currentInstance) {\r\n        const parentProviders = currentInstance.parent.providers;\r\n        if (key in parentProviders) {\r\n            return parentProviders[key];\r\n        }\r\n        else if (defaultValue) {\r\n            if (typeof defaultValue === 'function') {\r\n                return defaultValue();\r\n            }\r\n            return defaultValue;\r\n        }\r\n    }\r\n}\r\n\r\n// import {render} from \"./renderer\";\r\nfunction createAppAPI(render) {\r\n    return function createApp(rootComponent) {\r\n        // debugger\r\n        return {\r\n            // 接收一个element实例作为根容器，整体入口\r\n            mount(rootContainer) {\r\n                // 先转vNode  component -> vNode\r\n                // 所有逻辑操作都会基于vNode做处理\r\n                const vNode = createVNode(rootComponent);\r\n                render(vNode, rootContainer);\r\n            }\r\n        };\r\n    };\r\n}\r\n\r\nfunction shouldUpdateComponent(prevVNode, nextVNode) {\r\n    const { props: nextProps } = nextVNode;\r\n    const { props: prevProps } = prevVNode;\r\n    // 如果props长度不相等，直接返回true\r\n    if (Object.keys(nextProps).length !== Object.keys(prevProps).length) {\r\n        return true;\r\n    }\r\n    for (const key in nextProps) {\r\n        if (nextProps[key] !== prevProps[key]) {\r\n            return true;\r\n        }\r\n    }\r\n    // 执行到这里说明props没有变化\r\n    return false;\r\n}\r\n\r\n// 保存任务\r\nconst queue = [];\r\nlet isFlushPending = false;\r\nconst p = Promise.resolve();\r\nfunction nextTick(fn) {\r\n    return fn ? p.then(fn) : p;\r\n}\r\nfunction queueJobs(job) {\r\n    if (!queue.includes(job)) {\r\n        queue.push(job);\r\n    }\r\n    queueFlush();\r\n}\r\nfunction queueFlush() {\r\n    if (isFlushPending)\r\n        return;\r\n    isFlushPending = true;\r\n    nextTick(flushJobs);\r\n}\r\nfunction flushJobs() {\r\n    isFlushPending = false;\r\n    let job;\r\n    // 将这些任务添加到微任务队列\r\n    while (job = queue.shift()) {\r\n        job && job();\r\n    }\r\n}\r\n\r\nfunction createRender(options) {\r\n    const { createElement: hostCreateElement, patchProp: hostPatchProp, insert: hostInsert, remove: hostRemove, setElementText: hostSetElementText } = options;\r\n    function render(vNode, container) {\r\n        patch(null, vNode, container, null, null);\r\n    }\r\n    /*\r\n    * oldVNode - 不存在说明初始化，存在说明更新\r\n    * */\r\n    function patch(oldVNode, vNode, container, parentComponent, anchor) {\r\n        // ShapeFlags\r\n        const { shapeFlag, type } = vNode;\r\n        switch (type) {\r\n            case Fragment:\r\n                processFragment(oldVNode, vNode, container, parentComponent, anchor);\r\n                break;\r\n            case Text:\r\n                processText(oldVNode, vNode, container);\r\n                break;\r\n            default:\r\n                if (shapeFlag & 1 /* ShapeFlags.ELEMENT */) {\r\n                    processElement(oldVNode, vNode, container, parentComponent, anchor);\r\n                }\r\n                else if (shapeFlag & 2 /* ShapeFlags.STATEFUL_COMPONENT */) {\r\n                    // 去处理组件\r\n                    processComponent(oldVNode, vNode, container, parentComponent, anchor);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    function processComponent(oldVNode, vNode, container, parentComponent, anchor) {\r\n        // 如果存在老的虚拟节点\r\n        if (!oldVNode) {\r\n            mountComponent(vNode, container, parentComponent, anchor);\r\n        }\r\n        else {\r\n            updateComponent(oldVNode, vNode);\r\n        }\r\n    }\r\n    function updateComponent(oldVNode, vNode) {\r\n        // 与更新element同理 - 不需要更新的时候也是要执行的\r\n        const instance = (vNode.component = oldVNode.component);\r\n        if (shouldUpdateComponent(oldVNode, vNode)) {\r\n            // 下次要更新的虚拟节点\r\n            instance.next = vNode;\r\n            instance.update();\r\n        }\r\n        else {\r\n            vNode.el = oldVNode.el;\r\n            instance.vNode = vNode;\r\n        }\r\n    }\r\n    function mountComponent(initialVNode, container, parentComponent, anchor) {\r\n        // 与mountElement同理，创建并返回一个组件对象\r\n        // 将组件实例添加到虚拟节点对象上\r\n        const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent));\r\n        // 处理setup中的信息（例如：实现代理this）\r\n        setupComponent(instance);\r\n        setupRenderEffect(instance, initialVNode, container, anchor);\r\n    }\r\n    function processElement(oldVNode, vNode, container, parentComponent, anchor) {\r\n        if (!oldVNode) {\r\n            mountElement(vNode, container, parentComponent, anchor);\r\n        }\r\n        else {\r\n            patchElement(oldVNode, vNode, container, parentComponent, anchor);\r\n        }\r\n    }\r\n    function mountElement(vNode, container, parentComponent, anchor) {\r\n        // $el：这里的虚拟节点是element类型的，也就是App中的根元素div；return instance.vNode.el中的虚拟节点是组件实例对象的虚拟节点\r\n        // 创建对应的DOM，同时绑定到虚拟DOM上\r\n        const el = vNode.el = hostCreateElement(vNode.type);\r\n        const { children, shapeFlag } = vNode;\r\n        // 处理子节点 - 如果是string类型直接赋值给DOM元素的textContent属性\r\n        if (shapeFlag & 4 /* ShapeFlags.TEXT_CHILDREN */) {\r\n            el.textContent = children;\r\n        }\r\n        else if (shapeFlag & 8 /* ShapeFlags.ARRAY_CHILDREN */) {\r\n            // 如果是数组类型（说明有多个子元素），调用patch递归处理子节点\r\n            mountChildren(vNode.children, el, parentComponent, anchor);\r\n        }\r\n        // 处理vNode对应的属性\r\n        for (const key in vNode.props) {\r\n            const val = vNode.props[key];\r\n            hostPatchProp(el, key, null, val);\r\n        }\r\n        // 将DOM添加到对应容器中\r\n        hostInsert(el, container, anchor);\r\n    }\r\n    function patchElement(oldVNode, vNode, container, parentComponent, anchor) {\r\n        /*\r\n        * props\r\n        * children\r\n        * */\r\n        const oldProps = oldVNode.props || EMPTY_OBJECT;\r\n        const newProps = vNode.props || EMPTY_OBJECT;\r\n        const el = (vNode.el = oldVNode.el);\r\n        patchChildren(oldVNode, vNode, el, parentComponent, anchor);\r\n        patchProps(el, oldProps, newProps);\r\n    }\r\n    function patchChildren(oldVNode, newVNode, container, parentComponent, anchor) {\r\n        const prevShapeFlag = oldVNode.shapeFlag;\r\n        const oldChildren = oldVNode.children;\r\n        const shapeFlag = newVNode.shapeFlag;\r\n        const newChildren = newVNode.children;\r\n        if (shapeFlag & 4 /* ShapeFlags.TEXT_CHILDREN */) {\r\n            if (prevShapeFlag & 8 /* ShapeFlags.ARRAY_CHILDREN */) {\r\n                // 1.把老的清空\r\n                unmountChildren(oldVNode.children);\r\n            }\r\n            if (newChildren !== oldChildren) {\r\n                // 2.设置新的text\r\n                hostSetElementText(container, newChildren);\r\n            }\r\n        }\r\n        else {\r\n            if (prevShapeFlag & 4 /* ShapeFlags.TEXT_CHILDREN */) {\r\n                hostSetElementText(container, '');\r\n                mountChildren(newChildren, container, parentComponent, anchor);\r\n            }\r\n            else {\r\n                // array diff array\r\n                patchKeyedChildren(oldChildren, newChildren, container, parentComponent, anchor);\r\n            }\r\n        }\r\n    }\r\n    function patchKeyedChildren(c1, c2, container, parentComponent, parentAnchor) {\r\n        let i = 0, l2 = c2.length, e1 = c1.length - 1, e2 = l2 - 1;\r\n        function isSomeVNodeType(oldVNode, newVNode) {\r\n            return oldVNode.type === newVNode.type && oldVNode.key === newVNode.key;\r\n        }\r\n        // 左侧\r\n        while (i <= e1 && i <= e2) {\r\n            const oldVNode = c1[i];\r\n            const newVNode = c2[i];\r\n            if (isSomeVNodeType(oldVNode, newVNode)) {\r\n                patch(oldVNode, newVNode, container, parentComponent, parentAnchor);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        // 右侧\r\n        while (i <= e1 && i <= e2) {\r\n            const oldVNode = c1[e1];\r\n            const newVNode = c2[e2];\r\n            if (isSomeVNodeType(oldVNode, newVNode)) {\r\n                patch(oldVNode, newVNode, container, parentComponent, parentAnchor);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            e1--;\r\n            e2--;\r\n        }\r\n        if (i > e1) {\r\n            /* 新的比老的长 - 创建 */\r\n            if (i <= e2) {\r\n                const nextPos = e2 + 1;\r\n                const anchor = nextPos < l2 ? c2[nextPos].el : null;\r\n                while (i <= e2) {\r\n                    patch(null, c2[i], container, parentComponent, anchor);\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        else if (i > e2) {\r\n            /* 老的比新的长 - 删除 */\r\n            while (i <= e1) {\r\n                hostRemove(c1[i].el);\r\n                i++;\r\n            }\r\n        }\r\n        else {\r\n            /* 对比中间部分 */\r\n            let s1 = i;\r\n            let s2 = i;\r\n            // 新节点总数量\r\n            const toBePatched = e2 - s2 + 1;\r\n            // 处理过的数量\r\n            let patched = 0;\r\n            // 创建新节点的映射表\r\n            const keyToNewIndexMap = new Map();\r\n            let moved = false;\r\n            let maxNewIndexSoFar = 0;\r\n            let newIndexToOldInIndexMap = new Array(toBePatched);\r\n            // 初始化映射表  -  应该是填充 -1 - 标识没有建立映射关系\r\n            for (let j = 0; j < toBePatched; j++)\r\n                newIndexToOldInIndexMap[j] = 0;\r\n            for (let j = s2; j <= e2; j++) {\r\n                const nextChild = c2[j];\r\n                keyToNewIndexMap.set(nextChild.key, j);\r\n            }\r\n            for (let j = s1; j <= e1; j++) {\r\n                const prevChild = c1[j];\r\n                // 如果新节点已经被遍历完\r\n                if (patched >= toBePatched) {\r\n                    hostRemove(prevChild.el);\r\n                    continue;\r\n                }\r\n                let newIndex;\r\n                if (prevChild.key !== null) {\r\n                    // 查找旧节点在新节点列表中的下标\r\n                    newIndex = keyToNewIndexMap.get(prevChild.key);\r\n                }\r\n                else {\r\n                    for (let k = s2; k <= e2; k++) {\r\n                        if (isSomeVNodeType(prevChild, c2[k])) {\r\n                            newIndex = k;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (newIndex == undefined) {\r\n                    hostRemove(prevChild.el);\r\n                }\r\n                else {\r\n                    if (newIndex >= maxNewIndexSoFar) {\r\n                        maxNewIndexSoFar = newIndex;\r\n                    }\r\n                    else {\r\n                        moved = true;\r\n                    }\r\n                    /* TODO - 注意映射值 */\r\n                    newIndexToOldInIndexMap[newIndex - s2] = j + 1;\r\n                    patch(prevChild, c2[newIndex], container, parentComponent, null);\r\n                    // patch一个就意味着处理完一个\r\n                    patched++;\r\n                }\r\n            }\r\n            // 获取最长递增子序列\r\n            const increasingNewIndexSequence = getSequence();\r\n            let k = increasingNewIndexSequence.length - 1;\r\n            for (let j = toBePatched - 1; j >= 0; j--) {\r\n                const nextIndex = i + s2;\r\n                const nextChild = c2[nextIndex];\r\n                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : null;\r\n                if (newIndexToOldInIndexMap[j] === 0) {\r\n                    // 新创建节点\r\n                    patch(null, nextChild, container, parentComponent, anchor);\r\n                }\r\n                else if (moved) {\r\n                    if (k < 0 || j !== increasingNewIndexSequence[k]) {\r\n                        hostInsert(nextChild.el, container, anchor);\r\n                    }\r\n                    else {\r\n                        // 不需要移动\r\n                        k++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function unmountChildren(children) {\r\n        for (let i = 0; i < children.length; i++) {\r\n            const el = children[i].el;\r\n            // remove\r\n            hostRemove(el);\r\n        }\r\n    }\r\n    function patchProps(el, oldProps, newProps) {\r\n        if (oldProps !== newProps) {\r\n            for (const key in newProps) {\r\n                const prevProp = oldProps[key];\r\n                const nextProp = newProps[key];\r\n                if (prevProp !== nextProp) {\r\n                    hostPatchProp(el, key, prevProp, nextProp);\r\n                }\r\n            }\r\n            // 不存在老的props，不需要进行下面的操作\r\n            // if (!Object.keys(oldProps).length) return\r\n            if (oldProps !== EMPTY_OBJECT) {\r\n                for (const key in oldProps) {\r\n                    if (!(key in newProps)) {\r\n                        hostPatchProp(el, key, oldProps[key], null);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // 当children为数组时，处理子节点\r\n    function mountChildren(children, container, parentComponent, anchor) {\r\n        children.forEach(child => {\r\n            patch(null, child, container, parentComponent, anchor);\r\n        });\r\n    }\r\n    function processFragment(oldVNode, vNode, container, parentComponent, anchor) {\r\n        mountChildren(vNode.children, container, parentComponent, anchor);\r\n    }\r\n    function processText(oldVNode, vNode, container) {\r\n        const { children } = vNode;\r\n        const textNode = vNode.el = document.createTextNode(children);\r\n        container.append(textNode);\r\n    }\r\n    // 第一次渲染App组件的时候会执行，并且将render函数的this绑定为创建的代理对象\r\n    function setupRenderEffect(instance, vNode, container, anchor) {\r\n        /*\r\n        * 调用的组件实例的render方法结合组件的数据将视图渲染出来\r\n        *   因此更新的时候需要重新调用render函数渲染视图\r\n        *   将渲染操作使用effect包裹\r\n        * */\r\n        // 组件更新的话重新调用effect返回的runner\r\n        /*\r\n        * 数据修改后更新视图的操作不能立即执行 update，应该将他存到微任务中，执行栈清空的时候再去更新视图\r\n        * 通过设计响应式系统时的 scheduler 实现\r\n        * */\r\n        instance.update = effect(() => {\r\n            if (!instance.isMounted) { // 初始化\r\n                // instance.render 来自于 finishComponentSetup 方法，就是组件的render方法\r\n                // 绑定this，让render中的this指向创建的代理对象\r\n                // 然后通过this访问组件的信息时，会被实例的 proxy 对象拦截而获取实例的setup返回的数据或props中的数据\r\n                const subTree = (instance.subTree = instance.render.call(instance.proxy));\r\n                // vNode -> patch\r\n                // vNode -> element -> mountElement\r\n                patch(null, subTree, container, instance, anchor);\r\n                // subTree指的就是class=\"root\"的根节点\r\n                // 子元素处理完成之后\r\n                vNode.el = subTree.el;\r\n                instance.isMounted = true;\r\n            }\r\n            else { // 更新\r\n                // 需要一个更新完成后的虚拟节点，个更新之前的虚拟节点\r\n                const { next, vNode } = instance;\r\n                if (next) {\r\n                    next.el = vNode.el;\r\n                    updateComponentPreRender(instance, next);\r\n                }\r\n                const subTree = instance.render.call(instance.proxy);\r\n                const prevSubTree = instance.subTree;\r\n                instance.subTree = subTree; // 更新subTree\r\n                patch(prevSubTree, subTree, container, instance, anchor);\r\n            }\r\n        }, {\r\n            /*\r\n            * 视图更新时不会去立即触发传入effect的fn函数（不会立即更新视图）\r\n            * 将更新视图的操作放到 scheduler 中\r\n            * */\r\n            scheduler: () => {\r\n                queueJobs(instance.update);\r\n            }\r\n        });\r\n    }\r\n    function updateComponentPreRender(instance, nextVNode) {\r\n        instance.vNode = nextVNode;\r\n        instance.next = null;\r\n        instance.props = nextVNode.props;\r\n    }\r\n    return {\r\n        createApp: createAppAPI(render)\r\n    };\r\n}\r\nfunction getSequence(array) {\r\n    return [1, 3];\r\n}\r\n\r\nfunction createElement(type) {\r\n    return document.createElement(type);\r\n}\r\nfunction patchProp(el, key, prevVal, nextVal) {\r\n    const isOn = (key) => /^on[A-Z]/.test(key);\r\n    if (isOn(key)) {\r\n        const event = key.slice(2).toLowerCase();\r\n        el.addEventListener(event, nextVal);\r\n    }\r\n    else {\r\n        if (nextVal === undefined || nextVal === null) {\r\n            el.removeAttribute(key);\r\n        }\r\n        else {\r\n            el.setAttribute(key, nextVal);\r\n        }\r\n    }\r\n}\r\nfunction insert(child, container, anchor) {\r\n    container.insertBefore(child, anchor || null);\r\n    // container.append(el)\r\n}\r\nfunction remove(child) {\r\n    const parent = child.parentNode;\r\n    if (parent) {\r\n        parent.removeChild(child);\r\n    }\r\n}\r\nfunction setElementText(el, text) {\r\n    el.textContent = text;\r\n}\r\nconst renderer = createRender({\r\n    createElement,\r\n    patchProp,\r\n    insert,\r\n    remove,\r\n    setElementText\r\n});\r\nfunction createApp(...arg) {\r\n    return renderer.createApp(...arg);\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://github.io.demo/./src/static/guide-mini-vue-esm.js?");

/***/ }),

/***/ "./src/utils/providerVue.js":
/*!**********************************!*\
  !*** ./src/utils/providerVue.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _static_guide_mini_vue_esm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../static/guide-mini-vue-esm */ \"./src/static/guide-mini-vue-esm.js\");\n\r\n\r\nwindow.Vue = _static_guide_mini_vue_esm__WEBPACK_IMPORTED_MODULE_0__\r\n\n\n//# sourceURL=webpack://github.io.demo/./src/utils/providerVue.js?");

/***/ })

}]);