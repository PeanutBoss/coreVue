### 解析器

#### 1.文本模式及其对解析器的影响
当解析器遇到一些特殊标签时，会切换模式，从而影响其对文本的解析行为

#### 2.递归下降算法构造模板AST（有案例）
 - 当遇到字符 < 时，进入临时状态
    - 如果下一个字符匹配正则 /a-z/i，则认为这是一个标签节点，于是调用 parseElement 函数完成标签
        的解析。
    - 如果字符串以 <!-- 开头，则认为这是一个注释节点，调用 parseComment 函数完成注释节点的解析
    - 如果字符串以 <![CDATA[ 开头，则认为这是一个 CDATA 节点，调用parseCDATA函数完成节点解析
 - 如果字符串以 {{ 开头，则认为这是一个插值节点，于是调用 parseCDATA 函数完成插值节点的解析
 - 其他情况，都作为普通文本，调用 parseText 函数完成文本节点的解析

```javascript
function parseElement () {
  // 解析开始标签
  const element = parseTag()
  // 递归地调用 parseChildren 函数进行 <div> 标签子节点的解析
  element.children = parseChildren()
  // 解析结束标签
  parseEndTag()
  return element
}
```

 - parseTag解析开始标签。解析开始标签，包括标签上的属性和指令。因此在parseTag解析函数执行完毕，会消费字符串中的内容
    `<div>`，处理后的模板内容将变为`const template = '+--<p>Text1</p>+--<p>Text1</p>+</div>'`
 - 递归调用 parseChildren 函数解析子节点。parseElement 函数在解析开始标签时，会产生一个标签节点element。
    在parseElement函数执行完毕后，剩下的模板内容作为element的子节点被解析，即element.children。
    处理后内容变为 `const template = </div>`
 - parseEndTag处理结束标签。

#### 03.状态机的开始与停止（有案例）
 当解析器遇到开始标签时，会将该标签压入父级节点栈，同时开启新的状态机。当解析器遇到结束标签，并且父级节点站栈中
    存在于该标签同名的开始标签节点时，则停止当前正在运行的状态机。

```javascript
function isEnd (context, ancestors) {
  // 当模板内容解析完毕后，停止
  if (!context.source) return true
  // 获取父级标签节点
  const parent = ancestors[ancestors.length - 1]
  // 如果遇到结束标签，并且该标签与父级标签节点同名，则停止
  if (parent && context.source.startsWith(`</${parent.tag}>`)) {
    return true
  }
}
```

##### 另一种解析方式
_解析错误的标签时，无论怎样解析，对程序影响都不大，两者的具体区别体现在错误处理上_  

不应该总是于栈顶的父节点做比较，而是应该与整个父级节点站中的所有节点做比较。只要父级节点栈中存在于当前
  遇到的结束标签同名的节点，就停止状态机。

```javascript
function isEnd (context, ancestors) {
  if (!context.source) return true

  // 与父级节点栈内所有节点作比较
  for(let i = ancestors.length - 1; i >= 0; i++) {
    // 只要栈中存在与当前结束标签同名的节点，就停止状态机
    if (context.source.startsWith(`</${ancestors[i].tag}>`)) {
      return true
    }
  }
}
```

#### 4.解析标签节点
 - 完成正则匹配后，需要调用 advanceBy 函数消费由正则匹配的全部内容
 - 根据上面给出的第三个正则匹配例子可知，由于标签中可能存在无用的空白字符，因此需要调用advanceSpace消费空白字符
 - 在消费由正则匹配的内容后，需要检查剩余模板内容是否以字符串 /> 开头。如果是，则说明当前解析的是一个自闭和标签，
    这时需要将标签节点的 isSelfClosing 属性设置为true
 - 最后，判断标签是否自闭合，如果是 调用 advanceBy 消费内容 />，否则只需要消费内容 > 即可

#### 5.解析属性
```javascript
const ast = {
  type: 'Root',
  children: [
    {
      type: 'Element',
      tag: 'div',
      props: [
        { type: 'Attribute', name: 'id', value: 'dynamicId' },
        { type: 'Attribute', name: '@click', value: 'handler' },
        { type: 'Attribute', name: 'v-on:mousedown', value: 'onMouseDown' }
      ]
    }
  ]
}
```

name字段完整地保留着模板中编写地属性名称，还需要对属性做进一步分析，从而得到更具体地信息。

#### 6.解析文本与解码HTML实体

##### 文本解码

##### HTML实体解码

> 因为模板中的文本节点最终是通过如 el.textContent 等文本操作设置到页面的，二通过 el.textContent 设置的文本内容
>   是不会经过HTML实体解码的  
> 对于属性值的字符引用，如果最后一个匹配的字符不是分号，并且该匹配的字符下一个字符是等号、ASCII字母或数组，那么
>   该匹配项将作为普通文本被解析  

