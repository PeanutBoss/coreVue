### 解析三种联合类型

```typescript
export function baseParse (content: string) {
  // 创建一个全局上下文对象
  const context = createParserContent(content)
  return createRoot(parseChildren(context, ''))
}

function parseChildren (context, parentTag) {

  const nodes: any = []

  while (!isEnd(context, parentTag)) {
    let node
    const s = context.source
    if (s.startsWith('{{')) {
      node = parseInterpolation(context)
    } else if (s[0] === '<') {
      // 以 < 开头 且 < 后跟字母 说明遇到了标签
      if (/a-z/i.test(s[1])) {
        parseElement(context)
      }
      node = parseElement(context)
    }

    // 如果 node 没有值，则当作text解析
    if (!node) {
      node = parseText(context)
    }

    nodes.push(node)
  }

  return nodes
}

// 循环是否结束
function isEnd (context, parentTag) {
  // 1.遇到结束标签的时候
  // 2.source没有值的时候
  const s = context.source
  if (parentTag && s.startsWith(`</${parentTag}>`)) {
    return true
  }
  return !s
}

function parseText (context) {
  let endToken = '{{'
  let endIndex = context.source.length
// debugger
  const index = context.source.indexOf(endToken)
  // 判断是否遇到 {{，如果遇到了更新endIndex
  if (index !== -1) {
    endIndex = index
  }
  // debugger
  const content = parseTextData(context, endIndex)
  console.log(context, 'content----------------------------')
  return {
    type: NodeTypes.TEXT,
    content
  }
}
function parseElement (context: any, ancestors) {
  const element: any = parseTag(context, TagType.Start)

  // 这里进入一个新的标签内
  ancestors.push(element)
  // 添加children
  element.children = parseChildren(context, ancestors)
  // 处理完一个标签从栈中弹出
  ancestors.pop()

  if (startsWithEndTagOpen(context.source, element.tag)) {
    parseTag(context, TagType.End)
  } else {
    throw new Error(`缺少结束标签：${element.tag}`)
  }
  return element
}

function startsWithEndTagOpen (source, tag) {
  return source.startsWith('</') && source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase()
}
```
