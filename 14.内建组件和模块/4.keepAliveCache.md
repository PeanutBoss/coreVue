### 缓存管理

Map对象的键是组件选项对象，即vNode.type属性的值，而该Map对象的值是用于描述组件的vNode对象。

前面缓存的处理的逻辑可以总结为：
 - 如果缓存存在，则继承组件实例，并将用于描述组件的vNode对象标记为keptAlive，这样渲染器
    就不会重新创建新的组件实例
 - 如果缓存不存在，则设置缓存

_这里的问题在于，缓存不存在的时候总是会设置新的缓存。这会导致缓存不断增加，极端情况下会占用大量内存。_
_因此需要设置一个缓存阈值，当缓存数量超过指定阈值时对缓存进行删除。_  

删除缓存的策略叫做“最新一次访问”  

_缓存容量2_  
|访问顺序                          |最新组件           |被清理组件           |
|---------------------------------|-----------------|--------------------|
|Comp1 -> Comp2 -> Comp3          |Comp3            |Comp1               |
|Comp1 -> Comp2 -> Comp1 -> Comp3 |Comp1            |Comp2               |

实现内建的缓存策略需要加一个小算法（最旧一次删除）  
