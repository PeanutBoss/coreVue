### 实现effect & reactive & 依赖收集 & 依赖触发

> 响应式对象中包含一个容器，这个容器需要收集这个对象所有的依赖（通过effect收集）。

#### reactive

```javascript
// 测试用例
describe('reactive', () => {
  it('happy path', () => {
    const original = { foo: 1 } // 原始对象
    const observed = reactive(original) // 创建代理对象
    expect(observed).not.toBe(original) // 代理对象不等于原始对象
    expect(observed.foo).toBe(1) // 代理对象的foo属性等于1
  })
})
```

> 创建代理对象
>
> const proxyInstance = new Proxy(target, handlers)
>
> 创建代理对象的核心是处理器，关键的逻辑就在处理器中
>
> 先实现处理器的 get 和 set
>
> - get
>   - 返回代理对象中key对应的值
>   - 收集依赖
> - set
>   - 设置代理对象中key对应的值
>   - 触发依赖
>
> > 实现思路
> >
> > 创建代理对象并将其返回，核心在于收集和触发依赖

```javascript
// 实现reactive
function reactive (raw) {
  return new Proxy(
    raw,
    {
      get (target, key) {
        // todo 收集依赖
        track(target, key)
        return Reflect.get(target, key)
      },
      set (target, key, value) {
        // todo 触发依赖
        trigger(target, key)
        return Reflect.set(target, key, value)
      }
    }
  )
}
```

#### effect

> effect接受一个函数 fn，每次开始会调用 fn，调用 fn 时访问user.age，
>
> 触发了user对象的get方法，当触发get操作的时候，user对象就可以收集到这个fn，这个流程就是依赖收集。
>
> 当修改对象的时候，会触发代理对象的set方法，在set中会将所有的依赖调用一次，这个流程就是触发依赖。

```javascript
// 测试用例
describe('effect', () => {
  it('happy path', () => {
    // 1.user是一个响应式对象，响应式对象包含一个容器，需要收集它所有的依赖
    const user = reactive({ age: 10 })
    let nextAge
    // 2.通过effect收集依赖，传入一个cb并调用它
    effect(() => {
      // 3.调用cb会调用user这个响应式对象的get方法，触发get的时候
      // user响应式对象就可以把这个依赖收集起来
      nextAge = user.age + 1
    })
    expect(nextAge).toBe(11)
    // 更新触发依赖
    // 4.当触发set操作的时候，会把所有收集的依赖调用一遍
    user.age++
    expect(nextAge).toBe(12)
  })
})
```



```typescript
// 实现effect - 首次执行
// 抽象出一个类，保存fn，run方法执行fn
class ReactiveEffect {
  private _fn: any
  constructor (fn) {
    this._fn = fn
  }
  run () {
    this._fn()
  }
}

function effect (fn) {
  const _effect = new ReactiveEffect(fn)
  effect.run()
}
```

##### track - 收集依赖

```typescript
// 收集依赖
const targetMap = new Map() // 所有对象的依赖保存在这个全局变量中
let activeEffect // 需要将传入effct的fn保存起来，利用一个全局变量来获取它
export function track (target, key) {
  // 拿到这个对象对应的依赖项
  let depsMap = targetMap.get(target)
  if (!depsMap) { // 判空
    depsMap = new Map()
    targetMap.set(target, depsMap)
  }
  // 拿到这个key对应的依赖项（dep中保存的是所有effect实例而不是fn）
  let dep = depsMap.get(key)
  if (!dep) { // 判空
    dep = new Set()
	depsMap.set(key, dep)
  }
  // 将这个key对应的依赖添加到dep中
  dep.add(activeEffect)
}

// 对run方法进行优化
run () {
/*
将activeEffect赋值为effect实例
run方法正在执行的时候将effect实例赋值给activeEffect，然后会在fn执行的时候触发响应式对象的get方法（get方法中包含track），于是通过dep.add(activeEffect)将依赖项添加到了dep中
*/
  activeEffect = this
  this._fn()
}
```

##### trigget - 触发依赖

```typescript
function trigger (target, key) {
  // 基于target和key获取到dep（这个key对应的所有依赖项的集合），然后全部执行
  const depsMap = targetMap.get(target)
  const dep = depsMap.get(key)
  for (const effect of dep) {
    effect()
  }
}
```



