### CSR&SSR&同构渲染
SSR是在服务端完成模板和数据的融合，CSR是在浏览器中完成模板与数据的融合，并渲染出最终的HTML页面。

**SSR与CSR比较**  

|               |SSR            |CSR        |
|---------------|--------------|------------|
|SEO            |友好           |不友好       |
|白屏问题        |无             |有          |
|占用服务端资源   |多             |少          |
|用户体验        |差             |好          |

同构渲染分为首次渲染（即首次访问或刷新页面）以及非首次渲染。  
> 当首次访问或者刷新页面时，整个页面的内容是在服务端完成渲染的，渲染器最终得到的是渲染好的HTML页面。
>   但是页面是纯静态的，意味着用户还不能进行交互，因为整个应用程序的脚本还没有加载和执行。另外静态的
>   HTML页面也会包含 link script 等标签。  
> 除此之外，同构渲染所产生的HTML页面与SSR所产生的HTML页面有一点最大的不同，即前者会包含当前页面所需要
>   的初始化数据。即服务端通过API请求的数据会被序列化为字符串，并拼接到静态的HTML字符串中，最后一起发送给浏览器。
>   这么做是为了后续的激活操作。

激活操作包含两部分工作内容
 - Vue在当前页面已经渲染的DOM元素以及Vue组件所渲染的虚拟DOM之间建立联系
 - Vue从HTML页面中提取由服务端序列化后发送过来的数据，用来初始化整个Vue应用程序
 - 完成激活后，整个应用程序已经被Vue接管为CSR应用程序了
 

**SSR与CSR以及同构渲染比较**  

|               |SSR            |CSR        |通过渲染     |
|---------------|--------------|------------|------------|
|SEO            |友好           |不友好       |友好        |
|白屏问题        |无             |有          |无          |
|占用服务端资源   |多             |少          |中          |
|用户体验        |差             |好          |好          |

 - 由于同构渲染方案在首次渲染时和浏览器刷新时仍然需要服务端完成渲染工作，所以也需要部分服务端资源
 - 同构渲染并不能提升可交互事件，它仍然要像CSR那样等待JavaScript资源加载完成且客户端激活完成后，才能响应用户操作

### 将虚拟DOM渲染为HTML字符串

### 将组件渲染为HTML字符串

_未完成代码：P487 -> 3-2_  

> 服务端渲染的是应用的当前快照，他不存在数据变更后重新渲染的情况。因此，所有数据在服务端渲染都无需是响应式的  
> 服务端渲染只需要获取组件要渲染的 subTree 即可，无需调用渲染器完成正式DOM的创建

### 客户端激活的原理

> 浏览器在渲染了由服务端发送过来的HTML字符之后，页面中已经存在对应的DOM元素了，所以组件代码在客户端运行时，
>   不需要再次创建相应的DOM元素。  
> 但是，组件代码在客户端运行时，仍然需要做两件重要的事：  
>   - 在页面中的DOM元素与虚拟节点对象之间建立联系
>   - 为页面中的DOM元素添加事件绑定

需要在页面中已经存在的ODM对象与您节点对象之间建立正确的联系。在服务端渲染的过程中，会忽略虚拟节点
    中以事件相关的props。所以当组件代码在客户端运行时，需要将事件正确的绑定到元素上。  
当渲染需作用执行挂载操作时，优先检查虚拟节点 vNode.el 属性是否存在，如果存在，意味无需全新挂载，只需要
    进行记过操作即可。，否则仍然按照之前地略记进行全新地挂载。  
组件的激活操作需要在真实DOM与subTree之间进行

### 编写同构渲染的代码

#### 生命周期
 - 服务端渲染不会做真正的挂载操作，所以 beforeMount 与 mounted 这两个钩子函数不会执行
 - 服务端渲染不存在数据变化，所以 beforeUpdate 与 updated 这两个钩子函数也不会执行
 - 服务端渲染不会发生卸载操作，所以 beforeUnmount 与 unmounted 两个钩子函数也不会执行
 - 实际上，只有 beforeCreate 与 created 两个钩子函数会在服务端执行

> 如果存在定时器，移动到 mounted 中，即值在客户端执行定时器；
>   或者使用环境变量包裹代码，让它在不在服务端运行

```javascript
// 不是服务端渲染
const notSSR = !import.meta.env.SSR
export default {
    created () {
        if (notSSR) {
            this.timer = setInterval(() => { /* 做一些事 */ })
        }
    }
}
```

#### 使用跨平台的API
 避免使用平台特有的API。因为组件代码即运行于浏览器，又运行于服务器，所以避免使用平台特有的API

```javascript
const notSSR = !import.meta.env.SSR
if (notSSR) {
    // 使用浏览器特有的API
    window.xxx
}
```

#### 值在某一段引入模块
 使用条件引入

```javascript
const notSSR = !import.meta.env.SSR
let storage
if (notSSR) {
    storage = import('./storage.js')
} else {
    storage = import('./storage-server.js')
}
```

#### 避免交叉请求引起的状态污染
 服务端渲染时，每一个请求对应一个全新的应用实例

```javascript
import { createSSRApp } from 'vue'
import { renderToString } from '@vue/server-renderer'
import App from 'App.vue'

// 每个请求到来，都会执行一次 render 函数
async function render (url, manifest) {
  const app = createSSRApp(App)
  const ctx = {}
  const html = await renderToString(app, ctx)
  return html
}
```

全局变量谨慎使用，因为服务器与用户是一对多的关系，一个用户修改服务端数据可能会影响到另一个用户。
```javascript
// 模块级别的全局变量
let count = 0
export default {
    create () {
        count++
    }
}
```

#### <ClientOnly>组件
一些只能在服务端渲染的组件可以使用 ClientOnly 包裹

```javascript
const template = `
<template>
    <ClientOnly>
        <SsrIncompatibleComp/>
    </ClientOnly>
</template>
`
```
