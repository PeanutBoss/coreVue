### 更新element流程

```
function handleSetupResult (instance, setupResult) {
  // TODO
  if (typeof setupResult === 'object') {
    // 为ref类型的数据做代理，可以直接访问，不需要.value
    instance.setupState = proxyRef(setupResult)
  }
  finishComponentSetup(instance)
}
```

```
export function createComponentInstance (vNode, parent) {
  const component: any = {
    vNode,
    type: vNode.type,
    setupState: {},
    props: {},
    slots: {},
    providers: parent ? parent.providers : {},
    parent,
    isMounted: false, // 组件是否已经挂载
    subTree: {},
    emit: () => {}
  }
  component.emit = emit.bind(null, component)
  return component
}
```

```
function patch (oldVNode, vNode, container, parentComponent) {
  // ShapeFlags - &
  const { shapeFlag, type } = vNode

  switch (type) {
    case Fragment:
      processFragment(oldVNode, vNode, container, parentComponent)
      break
    case Text:
      processText(oldVNode, vNode, container)
      break
    default:
      if (shapeFlag & ShapeFlags.ELEMENT) {
        processElement(oldVNode, vNode, container, parentComponent)
      } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {
        // 去处理组件
        processComponent(oldVNode, vNode, container, parentComponent)
      }
      break
  }
}
```

```
function processElement (oldVNode, vNode, container, parentComponent) {
  if (!oldVNode) {
    mountElement(vNode, container, parentComponent)
  } else {
    patchElement(oldVNode, vNode, container)
  }
}
```

#### 更新props

```
function patchElement(oldVNode, vNode, container) {
  console.log('patchElement')
  console.log('oldVNode', oldVNode)
  console.log('vNode', vNode)

  /*
  * props
  * children
  * */
  const oldProps = oldVNode.props || EMPTY_OBJECT
  const newProps = vNode.props || EMPTY_OBJECT
  const el = (vNode.el = oldVNode.el)
  console.log(oldProps, 'oldProps', newProps, 'newProps')
  patchProps(el, oldProps, newProps)
}
```

```
function mountElement(vNode, container, parentComponent) {
  // $el：这里的虚拟节点是element类型的，也就是App中的根元素div；return instance.vNode.el中的虚拟节点是组件实例对象的虚拟节点
  // 创建对应的DOM，同时绑定到虚拟DOM上
  const el = vNode.el = hostCreateElement(vNode.type)
  const { children, shapeFlag } = vNode
  // 处理子节点 - 如果是string类型直接赋值给DOM元素的textContent属性
  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
    el.textContent = children
  } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
    // 如果是数组类型（说明有多个子元素），调用patch递归处理子节点
    mountChildren(vNode, el, parentComponent)
  }
  // 处理vNode对应的属性
  for (const key in vNode.props) {
    const val = vNode.props[key]
    hostPatchProp(el, key, null, val)
  }
  // 将DOM添加到对应容器中
  hostInsert(el ,container)
}
```

```
function patchProps (el, oldProps, newProps) {
  if (oldProps !== newProps) {
    for (const key in newProps) {
      const prevProp = oldProps[key]
      const nextProp = newProps[key]

      if (prevProp !== nextProp) {
        hostPatchProp(el, key, prevProp, nextProp)
      }
    }

    // 不存在老的props，不需要进行下面的操作
    // if (!Object.keys(oldProps).length) return
    if (oldProps !== EMPTY_OBJECT) {
      for (const key in oldProps) {
        if (!(key in newProps)) {
          hostPatchProp(el, key, oldProps[key], null)
        }
      }
    }
  }
}
```

runtime-dom

```
function patchProp (el, key, prevVal, nextVal) {
    console.log('patchProp')
    const isOn = (key: string) => /^on[A-Z]/.test(key)
    if (isOn(key)) {
      const event = key.slice(2).toLowerCase()
      el.addEventListener(event, nextVal)
    } else {
        if (nextVal === undefined || nextVal === null) {
            el.removeAttribute(key)
        } else {
            el.setAttribute(key, nextVal)
        }
    }
}
```

#### 更新children

```
function patchChildren (oldVNode, newVNode, container, parentComponent) {

  const prevShapeFlag = oldVNode.shapeFlag
  const oldChildren = oldVNode.children
  const shapeFlag = newVNode.shapeFlag
  const newChildren = newVNode.children

  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
    if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      // 1.把老的清空
      unmountChildren(oldVNode.children)
    }
    if (newChildren !== oldChildren) {
      // 2.设置新的text
      hostSetElementText(container, newChildren)
    }
  } else {
    hostSetElementText(container, '')
    mountChildren(newChildren, container, parentComponent)
  }

}

function unmountChildren (children) {
  for (let i = 0; i < children.length; i++) {
    const el = children[i].el
    // remove
    hostRemove(el)
  }
}
```

```
function mountChildren (children, container, parentComponent) {
  children.forEach(child => {
    patch(null, child, container, parentComponent)
  })
}

function processFragment (oldVNode, vNode, container, parentComponent) {
  mountChildren(vNode.children, container, parentComponent)
}
```