### 自定义渲染器

> 渲染器不仅能够把虚拟DOM渲染为浏览器平台上的真实DOM，通过将渲染器设计为可配置的”通用“
> 
> 渲染器，即可实现渲染到任意目标平台上。  
> 
> 设计一个不依赖于平台的渲染器，但很明显目前的DOM操作调用了大量依赖于浏览器的API，例如
> 
> document.creatElement\textContent等。  
> 
> 因此实现通用的渲染器，第一步要做的就是将浏览器特有的API抽离。

#### 抽离特定平台的API

将renderer.ts中依赖浏览器的操作抽离到runtime-dom/index.ts中

```typescript
function createElement (type) {
    return document.createElement(type)
}

function patchProp (el, key, val) {
    const isOn = (key: string) => /^on[A-Z]/.test(key)
    if (isOn(key)) {
      const event = key.slice(2).toLowerCase()
      el.addEventListener(event, val)
    } else {
      el.setAttribute(key, val)
    }
}

function insert (el, container) {
    container.append(el)
}
```

#### createRenderer

> renderer.ts中只暴露出createRenderer即可，createRenderer的核心是render函数，内部的操作全部依赖于createRenderer函数内部声明的方法（将render暴露出去形成一个闭包），所以使用渲染器时只要能拿到render函数就行。  
> 
> 在调用createRenderer的时候传入配置项，runtime-dom中抽离的操作。

```typescript
export function createRenderer (options) {

  const {
    createElement: hostCreateElement,
    patchProp: hostPatchProp,
    insert: hostInsert
  } = options

  function render (vNode, container) {}
  function patch (vNode, container, parentComponent) {}
  function processComponent (vNode, container, parentComponent) {}
  function mountComponent (vNode, container, parentComponent) {}
  function processElement (vNode, container, parentComponent) {}
  function mountElement(vNode, container, parentComponent) {
    // 省略
    // const el = vNode.el = document.createElement(vNode.type) 改为
    const el = vNode.el = hostCreateElement(vNode.type)
    // 省略

    // const isOn = (key: string) => /^on[A-Z]/.test(key)
    // if (isOn(key)) {
    //   const event = key.slice(2).toLowerCase()
    //   el.addEventListener(event, val)
    // } else {
    //   el.setAttribute(key, val)
    // } 改为
    hostPatchProp(el, key, val)
    // 省略

    // container.appendChild(el) 改为
    hostInsert(el ,container)
  }
  function mountChildren (vNode, container, parentComponent) {}
  function processFragment (vNode, container, parentComponent) {}
  function processText (vNode, container) {}
  function setupRenderEffect (instance, vNode, container, parentComponent) {}

}
```

可以看到 mountElement 中依赖于平台的操作全部被抽离出来，并且作为 createRenderer 的参数使用。

因此将renderer文件改造为只导出 createRenderer API。

#### createApp

因为renderer.ts不再暴露render函数，所以createApp将不能得到核心的渲染方法。  

因此需要改造createApp，让其暴露出一个新的API，这个API接收一个render方法作为参数，返回原来意义的createApp。

```typescript
import {createVNode} from "./vNode";
// import {render} from "./renderer";

export function createAppAPI(render) {
  return function createApp (rootComponent) {
    // debugger
    return {
      // 接收一个element实例作为根容器，整体入口
      mount (rootContainer) {
        // 先转vNode  component -> vNode
        // 所有逻辑操作都会基于vNode做处理
        const vNode = createVNode(rootComponent)
        render(vNode, rootContainer)
      }
    }
  }
}
```

#### 整合createRenderer和createApp

上面说到 createRenderer 这个API核心在于render函数，而 createAppAPI 这个改造后的API需要接收render方法，将这两个关联起来更新renderer.ts  

**将 createApp 包装到了渲染器函数返回的渲染器中**

```typescript
import { createAppAPI } from './createApp'

export function createRenderer (options) {
    // 省略
    return {
      createApp: createAppAPI(render)
    }
}
```

#### 重新声明createApp

最后在runtime-dom/index.ts中重新声明createApp并返回，这个createApp返回的渲染器，具体的操作都是基于浏览器平台的；如果需要依赖于其他平台的渲染器，只需要创建对应平台的操作函数，作为createRenderer的参数传入，就能得到对应平台的渲染器  

```typescript
const renderer: any = createRender({
    createElement,
    patchProp,
    insert
})

export function createApp (...arg) {
    return renderer.createApp(...arg)
}
```

#### 导出层级

在src/index.ts中，之前是直接从runtime-core中导出所有API。但现在有了runtime-dom，runtime-dom是基于runtime-core实现的，所以比 runtime-core高上一层，因此：

在src/index只需要导出runtime-dom中所有的API - export * from './runtime-dom'  

在runtime-dom中导出所有runtime-core的API - export * from '../runtime-core'  


