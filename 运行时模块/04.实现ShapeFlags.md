### ShapeFlags

虚拟节点的类型

- ELEMENT - 
- STATEFUL_COMPONENT
- TEXT_CHILDREN
- ARRAY_CHILDREN
- SLOT_CHILDREN

对象形式的不够高效，所以采用位运算的方式

创建虚拟节点时，根据组件信息设置它的ShapeFlag属性，渲染时根据ShapeFlag属性决定具体操作

```typescript
// 获取虚拟节点类型，是组件还是标签元素
function getShapeFlag (type) {
  return typeof type === 'string'
    ? ShapeFlags.ELEMENT
    : ShapeFlags.STATEFUL_COMPONENT
}

export function createVNode (type, props?, children?) {
  const vNode = {
    type,
    props,
    children,
    component: null,
    key: props && props.key,
    shapeFlag: getShapeFlag(type),
    el: null
  }
  // 创建虚拟节点时根据子节点类型设置ShapeFlag
  if (typeof children === 'string') {
    vNode.shapeFlag |= ShapeFlags.TEXT_CHILDREN
  } else if (Array.isArray(children)) {
    vNode.shapeFlag |= ShapeFlags.ARRAY_CHILDREN
  }
  // slot - 组件&object
  if (vNode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {
    if (typeof children === 'object') {
      vNode.shapeFlag |= ShapeFlags.SLOT_CHILDREN
    }
  }
  return vNode
}
```

```typescript
function patch (oldVNode, vNode, container, parentComponent, anchor) {
    // ShapeFlags
    const { shapeFlag, type } = vNode

    switch (type) {
      case Fragment:
        processFragment(oldVNode, vNode, container, parentComponent, anchor)
        break
      case Text:
        processText(oldVNode, vNode, container)
        break
      default:
        if (shapeFlag & ShapeFlags.ELEMENT) {
          processElement(oldVNode, vNode, container, parentComponent, anchor)
        } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {
          // 去处理组件
          processComponent(oldVNode, vNode, container, parentComponent, anchor)
        }
        break
    }
  }

function mountElement(vNode, container, parentComponent, anchor) {
    // $el：这里的虚拟节点是element类型的，也就是App中的根元素div；return instance.vNode.el中的虚拟节点是组件实例对象的虚拟节点
    // 创建对应的DOM，同时绑定到虚拟DOM上
    const el = vNode.el = hostCreateElement(vNode.type)
    const { children, shapeFlag } = vNode
    // 处理子节点 - 如果是string类型直接赋值给DOM元素的textContent属性
    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
      el.textContent = children
    } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
      // 如果是数组类型（说明有多个子元素），调用patch递归处理子节点
      mountChildren(vNode.children, el, parentComponent, anchor)
    }
    // 处理vNode对应的属性
    for (const key in vNode.props) {
      const val = vNode.props[key]
      hostPatchProp(el, key, null, val)
    }
    // 将DOM添加到对应容器中
    hostInsert(el ,container, anchor)
  }

function patchChildren (oldVNode, newVNode, container, parentComponent, anchor) {

    const prevShapeFlag = oldVNode.shapeFlag
    const oldChildren = oldVNode.children
    const shapeFlag = newVNode.shapeFlag
    const newChildren = newVNode.children

    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        // 1.把老的清空
        unmountChildren(oldVNode.children)
      }
      if (newChildren !== oldChildren) {
        // 2.设置新的text
        hostSetElementText(container, newChildren)
      }
    } else {
      if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
        hostSetElementText(container, '')
        mountChildren(newChildren, container, parentComponent, anchor)
      } else {
        // array diff array
        patchKeyedChildren(oldChildren, newChildren, container, parentComponent, anchor)
      }
    }
  }
```



