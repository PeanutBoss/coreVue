### nextTick

```
function setupRenderEffect (instance, vNode, container, anchor) {
  /*
  * 调用的组件实例的render方法结合组件的数据将视图渲染出来
  *   因此更新的时候需要重新调用render函数渲染视图
  *   将渲染操作使用effect包裹
  * */
  // 组件更新的话重新调用effect返回的runner
  /*
  * 数据修改后更新视图的操作不能立即执行 update，应该将他存到微任务中，执行栈清空的时候再去更新视图
  * 通过设计响应式系统时的 scheduler 实现
  * */
  instance.update = effect(() => {
    if (!instance.isMounted) { // 初始化
      console.log('init')
      // instance.render 来自于 finishComponentSetup 方法，就是组件的render方法
      // 绑定this，让render中的this指向创建的代理对象
      const subTree = (instance.subTree = instance.render.call(instance.proxy))
      // vNode -> patch
      // vNode -> element -> mountElement
      patch(null, subTree, container, instance, anchor)

      // subTree指的就是class="root"的根节点
      // 子元素处理完成之后
      vNode.el = subTree.el

      instance.isMounted = true
    } else { // 更新
      console.log('update')

      // 需要一个更新完成后的虚拟节点，个更新之前的虚拟节点
      const { next, vNode } = instance
      if (next) {
        next.el = vNode.el
        updateComponentPreRender(instance, next)
      }

      const subTree = instance.render.call(instance.proxy)
      const prevSubTree = instance.subTree

      instance.subTree = subTree // 更新subTree

      patch(prevSubTree, subTree, container, instance, anchor)
    }
  }, {
    /*
    * 视图更新时不会去立即触发传入effect的fn函数（不会立即更新视图）
    * 将更新视图的操作放到 scheduler 中
    * */
    scheduler: () => {
      console.log('update-scheduler')
      queueJobs(instance.update)
    }
  })
}
```

```
// 保存任务
const queue: any[] = []
let isFlushPending = false

const p = Promise.resolve()

export function nextTick (fn) {
   return fn ? p.then(fn) : p
}

export function queueJobs (job) {
    if (!queue.includes(job)) {
        queue.push(job)
    }
    queueFlush()
}

function queueFlush () {
    if (isFlushPending) return
    isFlushPending = true
    nextTick(flushJobs)
}

function flushJobs () {
    isFlushPending = false
    let job
    // 将这些任务添加到微任务队列
    while (job = queue.shift()) {
        job && job()
    }
}
```

