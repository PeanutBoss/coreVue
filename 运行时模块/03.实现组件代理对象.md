### 实现组件代理对象

#### 处理组件流程

- processComponent
  - mountComponent
    - createComponentInstance - 创建组件实例
    - setupComponent - 处理setup中的信息（代理this）
      - initProps - 处理组件的props
      - initSlots - 处理组件的
      - setupStatefulComponent - 创建组件的代理对象并添加到组件实例的proxy属性上
    - setupRenderEffect - 收集组件的依赖，当组件依赖的数据发生改变时重新渲染组件；**将render函数的this绑定为上一步创建的代理对象**（挂载组件的时候会执行）

##### setupStatefulComponent 

```typescript
const publicPropertiesMap = {
    $el: i => i.vNode.el,
    $slots: i => i.slots,
    $props: i => i.props
}

export const PublicInstanceProxyHandlers = {
    // 取出组件的实例对象 instance
    get({_: instance}, key) {
      // 从组件实例中取出 setupState（setup返回的数据） / props（传入当前组件的数据）
      const { setupState, props } = instance
      // 当通过代理对象访问某个属性时，会先从 setupState 中查找并返回
      if (hasOwn(setupState, key)) {
        return setupState[key]
      } else if (hasOwn(props, key)) { // 如果setupState中没有，则到props中查找并返回
        return props[key]
      }
      // 访问 $el、$slots、$props时，返回实例上对应的属性
      const publicGetter = publicPropertiesMap[key]
      if (publicGetter) {
        return publicGetter(instance)
      }
    }
}

function setupStatefulComponent(instance) {
  // 第一次patch的时候instance.type就是传入的App组件
  const Component = instance.type

  // 创建一个代理对象用来拦截render函数中的this  目标对象有一个 _ 属性，它的值是当前组件的实例对象
  instance.proxy = new Proxy({ _: instance }, PublicInstanceProxyHandlers)

  const { setup } = Component

  if (setup) {
    // currentInstance = instance
    setCurrentInstance(instance)
    // 因为传入的props是浅只读的，所以使用 shallowReadonly 包裹
    const setupResult = setup(shallowReadonly(instance.props), {
      emit: instance.emit,
    })
    // currentInstance = null
    setCurrentInstance(null)
    handleSetupResult(instance, setupResult)
  }
}
```

##### setupRenderEffect 

```typescript
instance.update = effect(() => {
      if (!instance.isMounted) { // 初始化
        console.log('init')
        // instance.render 来自于 finishComponentSetup 方法，就是组件的render方法
        
        // 绑定this，让render中的this指向创建的代理对象
        // 然后通过this访问组件的信息时，会被实例的 proxy 对象拦截而获取实例的setup返回的数据或props中的数据
        const subTree = (instance.subTree = instance.render.call(instance.proxy))
        
        // vNode -> patch
        // vNode -> element -> mountElement
        patch(null, subTree, container, instance, anchor)

        // subTree指的就是class="root"的根节点
        // 子元素处理完成之后
        vNode.el = subTree.el

        instance.isMounted = true
      } else { // 更新
        console.log('update')

        // 需要一个更新完成后的虚拟节点，个更新之前的虚拟节点
        const { next, vNode } = instance
        if (next) {
          next.el = vNode.el
          updateComponentPreRender(instance, next)
        }

        const subTree = instance.render.call(instance.proxy)
        const prevSubTree = instance.subTree

        instance.subTree = subTree // 更新subTree

        patch(prevSubTree, subTree, container, instance, anchor)
      }
    }, {
      /*
      * 视图更新时不会去立即触发传入effect的fn函数（不会立即更新视图）
      * 将更新视图的操作放到 scheduler 中
      * */
      scheduler: () => {
        console.log('update-scheduler')
        queueJobs(instance.update)
      }
    })
```

