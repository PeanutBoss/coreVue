### Provider - Inject

> provider/inject实际上就是数据的存取，将数据存在当前组件上，后代组件需要用的时候直接就能取到。

- provide    存

- inject    取

#### 单层传递

##### 创建组件实例时添加providers和parent属性。

```typescript
export function createComponentInstance (vNode, parent) {
  console.log(parent, 'parent')
  const component: any = {
    vNode,
    type: vNode.type,
    setupState: {},
    props: {},
    slots: {},
    providers: {},
    parent,
    emit: () => {}
  }
  // 省略
}
```

provide获取当前组件实例，然后将传入provide的key-value添加到当前组件实例的providers属性中  

**provider/inject只能在setup下使用,因为只有在setup中使用才setup中才能正确获取到currentInstance**  

读取的时候获取当前组件，然后获取当前组件的parent属性（保存当前组件的父组件），从父组件中的providers中根据传入inject的key来获取数据

```typescript
import { getCurrentInstance } from "./component";

export function provider (key, value) {
    // 存
    const currentInstance: any = getCurrentInstance()
    if (currentInstance) {
        const { providers } = currentInstance
        providers[key] = value
    }
}

export function inject (key) {
    // 取
    const currentInstance: any = getCurrentInstance()
    if (currentInstance) {
        const parentProviders = currentInstance.parent.providers
        return parentProviders[key]
    }
}
```

##### 添加parent

_创建组件和更新时需要为对应的组件添加parent属性，设计方法都需要修改（添加parent参数）__  

- mountComponent (vNode, container, parentComponent)

- setupRenderEffect(instance, vNode, container, parentComponent)

- processElement (vNode, container, parentComponent)

- mountElement(vNode, container, parentComponent)

- processFragment (vNode, container, parentComponent)

- 省略、git提交记录中可以看到...

#### 多层传递

##### 初始化providers

创建组件实例，声明providers属性时，如果有父组件，则使用父组件的providers；

否则（当前组件为跟组件）给其赋值为空对象

```typescript
function createComponentInstance (vNode, parent) {
  console.log(parent, 'parent')
  const component: any = {
    vNode,
    type: vNode.type,
    setupState: {},
    props: {},
    slots: {},
    providers: parent ? parent.providers : {},
    parent,
    emit: () => {}
  }
  // 省略
}
```

##### 参考原型链

_目前的 provider/inject 只能访问到父级的provider，如果再深一层变访问不到了_  

> 这个可以参考原型链，如果对象中没有某个数据的话会从它的原型链一直查找下去  
> 
> 因此在保存数据的时候先获取到父级的providers，并重写当前组件的providers属性，以父级的providers为原型
> 
> 创建新的对象，该对象就是当前组件的providers  
> 
> 需要注意的是，只有初始化的时候才执行这样的操作，否则之前定义的组件的providers会被重写  
> 
> 通过`providers === parentProviders`来判断是否初始化，如果结果是 true，说明

```typescript
function provider (key, value) {
    // 存
    const currentInstance: any = getCurrentInstance()
    if (currentInstance) {
        let { providers } = currentInstance
        const parentProviders = currentInstance.parent.providers
        // 初始化的时候才会执行
        if (providers === parentProviders) {
            providers = currentInstance.providers = Object.create(parentProviders)
        }
        providers[key] = value
    }
}
```

#### Inject默认值

> inject从provider中读取数据时，如果key存在providers中但value不存在，则返回默认值

```typescript
function inject (key, defaultValue) {
    // 取
    const currentInstance: any = getCurrentInstance()
    if (currentInstance) {
        const parentProviders = currentInstance.parent.providers
        return parentProviders[key]
        if (key in  parentProviders) {
            return parentProviders[key]
        } else if (defaultValue) {
            if (typeof defaultValue === 'function') {
                return defaultValue()
            }
            return defaultValue
        }
    }
}
```
